/** LECTURE 10: Features of Java
 * ################################################################################# 
 * 	- Features of Java:
 * 		1. PLATFORM INDEPENDENT: as the BYTECODE is generated by the compiler which then in verified & interpreted by the JVM
 * 		2. ROBUST: as java has GARBAGE COLLECTION & EXCEPTION HANDLING
 * 		3. INTERNET FRIENDLY: coz of its platform independent nature where the bytecode generated once can be run any number of time
 * 					on any machine that has a JVM 
 * 		4. MULTI-THREADED: Execution of java program is achieved by diving one flow control into multiple threads of control
 * 						   where each thread can be run simultaneously by the processor thus reducing the processing time						
 * 		5. OBJECT-ORIENTED: Provides INHERANT SECURITY feature to the data of the program & also provide RE-USABILITY of the code
 * 		6. DISTRIBUTED DESIGN: Where different class of the application can be defined independently & later ASSEMBLED & PACKAGED together
 * 
 * 	- CONSTRUCTORS are the methods used to INITALIZE the properties/variable of the class when INSTANTIATED. 
 *    Variable are initialized with default value if no explicit values are provided for initialization
 *  	1. Are invoked when an object is INTANTIATED using NEW operator
 *  	2. Java always provides a DEFAULT, no-argument, PUBLIC constructor 
 *  	3. There definition is same as that of any method in a class with two exception
 *  		-> NAME is same as the class name itself
 *  		-> They have NO RETURN TYPE specified
 *  	4. Constructors can also be OVERLOADED i.e multiple definition each one varying in parameter list supplied
 *  	5. They are generally PUBLIC since we want the objects of the class to be created but there can also be PRIVATE constructor for below reasons:
 *  		-> Only want objects to be created internally - implements a SINGLETON(DESIGN PATTERN that allows only one instance of a class to be created)
 *  		-> To prevent object construction entirely - If a class contains only static members, those members can be accessed using the class name itself: no instance of the class is needed.
 */

/** LECTURE 11: Packages
 * ################################################################################# 
 *  - PACAKAGE is a LOGICAL grouping of classes & interfaces. 
 *  	1. They resemble DIRECTORIES of files where the the directories contains CLASS FILES
 *  	2. They are defined when a group of classes & interfaces COLLABORATE with each other to accomplish a task
 *  	3. When we want to RE_USE the functionality of a group of classes, we need to import the associated package into the CLASS DEFINITION & use objects available in the package
 *  							import package_name;
 *  	4. They prevent NAMING CLASHES among classes as the package defines a SCOPE for the Classes
 *  	5. In order to INCLUDE a class in a package, call definition should be prefixed with a package name 
 *  							package package_name;
 *  							 class class_name{ .. }
 *  	6. They provide INTERMEDIARY ACCESS(PROTECTED) to private & public to data members of the class
 *  	7. All the packages need to be NAMES in LOWER CASE letters
 *  	8. All the packages including user defined are LOCATED relative to base_location that is defined by the class path of JDK(Java Development Kit) 	 
 *	
 *	- APIs(APPLICATION PROGRAMMING INTERFACE) are message format used by an application program to communicate with the OS 
 *    or control program such as a database management system (DBMS) or communications protocol. 
 *    API in java are implemented through PACKAGES
 */ 

/** LECTURE 12: Inheritance
 * #################################################################################
 * 	- INHERITANCE is a mechanism to reuse the code & functionality of a class to create new class
 * 		1. EXTEND the CAPABIITIES of the class by either defining or change(OVER-RIDING) the capabilities as needed
 * 		2. Classes are inherited with a key word EXTENDS followed by the name of the class which is inherited.
 * 				class new_class extends existing_class{ .. }
 * 					new_class -> CHILD/SUB CLASS
 * 					existing_class -> PARENT/BASE/SUPER CLASS
 * 
 *	- Types of Inheritance:
 *		1. SINGLE LEVEL: Only one base class & one child class
 *				Base class(Circle) -> Child class(Cylinder)
 *		2. MULTI-LEVEL: Pattern of inheriting one class from another at various level i.e Child class of an inheritance becomes the Base class at next level
 *				Class Person -> Class Student -> Class Research_Assistant
 *		3. HIERARCHICAL: Once base class is extended by multiple child classes 
 *				Class Person -> Class Carpenter, Class Doctor, Class Engineer
 *
 *	- METHOD OVERRIDING: Is a process of redefining a method in the child class
 *		1. This is done only when the child class needs to modify the functionality of the Base class
 *		2. To override a method, definition of the method in the Child class must have the same 
 *		   SIGNATURE(return type, method name & parameter list) as that of the method in the Base class but new definition
 *		3. Key word SUPER is used to access the method in the base/super class		
 */ 

/** LECTURE 13: Abstract Classes
 * #################################################################################
 * 	- ABSTRACT CLASS is one where the complete behavior of the class is not defined.
 * 		1. Prefixed with ABSTRACT key word for the class definition
 * 					abstract class class_name{ ..}
 * 		2. Have one or more ABSTARCT METHODS(no definition, only declaration is present) & have ABSTRACT key word prefixed
 * 					abstract return_type method_name(parameters){ .. }
 * 		3. Abstract classes can only be INHERITED but not INSTANTIATED
 * 					class Concrete_class EXTENDS abtsract_Class { .. }
 * 		4. Since the abstract classes can not be instantiated, they will NOT HAVE any CONSTRUCTORS
 * 		5. Base class could be an abstract class which has few abstract methods which then get defined in the 
 * 		   inherited child class(method definition is NOT prefixed with ABSTRACT key word now!!).
 * 		   Child class can then be instantiated to invoke all the methods.
 * Abstract class is more appropriate when there is a STRONG RELATIONSHIP between abstract class & the classes that will DERIVES from it.
 * As abstract class is very closely linked to INHERITANCE.	
 * 
 *  - CONCRETE CLASS: Any NON-ABSTARCT class is called a concrete class
 *  	1. A concrete class has concrete methods, i.e., with code & other functionality. 
 *  	2. It a may EXTEND an abstract class or IMPLEMENT an interface
 *  Note: Cannot have more than one public class in a single class file	
 */

/** LECTURE 14: Interfaces
 * #################################################################################
 * 	- INTERFACE is NOT a Class but is essentially a TYPE that can be satisfied by any class that IMPLEMENTS the interface.
 * 		1. ALL methods of the class are ABSTRACT i.e no methods are defined.
 * 		2. Definition of an interface is similar to class definition where the key word "INTERFACE" is used in place of "CLASS"
 * 					public interface interface_name{
 * 														declaration of constants
 * 														method signature/prototype
 * 													}		
 * 		3. If a method is defined in an interface class then it is STATIC FINAL Method i.e it can not be OVERRIDEN
 * 		4. Interfaces can not be INSTANTIATED just like abstract classes & so will NOT have any CONSTRUCTORS
 * 		5. In order to USE an interface, it must be IMPLEMENETED by a certain class. 
 *         Class which implements the interface uses the key word "IMPLEMENTS" in place of "EXTENDS
 *         				class class_name IMPLEMENTS interface_name{ 
 *         															Implements all the abstract methods of the interface
 *         															}
 *      6. If a child class is implementing the interface then it need to define all the behaviors of the interface 
 *         else the child class is an ABSTARCT class which can not be instantiated.
 *         There need NOT BE a STRING RELATIONSHIP between the interface & the classes that IMPLEMENTS the interface.
 *      7. Java does NOT SUPPORT multiple inheritance(Prevent DIAMOND Problem) i.e it can not inherit from multiple classes( not same as MULTI-LEVEL)
 *      	But a class can IMPLEMENT MULTIPLE INTERFACES -> closet to multiple inheritance         
 */

/** LECTURE 15: Inputs & Outputs
 * #################################################################################
 * 	- Java interprets I/O data as STREAMS of DATA & they are handled through one of the following forms:
 * 		1.ByteStream : Used to read data in bytes
 * 		2.CharacterStream : Used to read data one character at a time
 * 		3.BufferedStream : An additional buffer is allocated for the stream in MAIN MEMORY
 * 
 * 	- All the I/O functions are implemented in a package called JAVA.IO  and Streams are handled through class such as:
 * 		1. BufferedStream
 * 		2. InputStreams
 * 		3. OutputStreams
 * 		which in turn have classes for handling inputs & outputs
 * 
 * 	- SYSTEM.IN.READ() : 
 * 		1. Reading input from KEYBOARD is done using this function
 *    	2. Reads one byte of data from the input stream at a time 
 *    	3. Byte value is returned as an int in the range 0-255
 *   
 *   - WRAPPER CLASS: The primitive data types are not objects; they do not belong to any class; 
 *     they are defined in the language itself. Sometimes, it is required to convert data types into objects in Java language 
 *   		1. Wraps (encloses) around a data type & gives it an object appearance. 
 *     	   	   Wherever, the data type is required as an object, this object can be used. 
 *      	2. Wrapper classes include methods to unwrap the object & give back the data type. 
 *   	
 *   	It can be compared to CHOCOLATES ->Manufacturer wraps the chocolate with some foil to prevent from pollution. 
 *   	The user takes the chocolate, removes & throws the wrapper and eats it.
 *   			int k = 100;
 *				Integer it1 = new Integer(k); -> WRAPPING
 *				int m = it1.intValue(); -> UNWRAPPING
 *
 *		Wrapper class hierarchy for primitive/basic data types
 *			Object -> Number, Character, Boolean 
 *			Number -> Byte, Short, Integer,Long, Float, Double
 *
 *		There are mainly two uses with wrapper classes:
 *			1. Convert simple data types into objects-> constructors are used (Integer(k))
 *			2. Convert strings into data types (known as parsing operations)-> methods of type parseXXX()(parseInt(k))
 *    
 * 	- SCANNER Class:
 * 		1. Used to read & write FORMATTED data
 * 		2. It can be used as a WRAPPER class to any other STREAM class(InputStreamReader) to format the data
 *  
 * - Input from the KEYBOARD are read using the below input stream class
 * 				-> ByteArrayInputStream
 * 				-> CharArrayReader
 * 				-> BufferedInputStream, BufferedReader
 * 				-> InputStream(Most commonly used): System.in.read()
 * 				-> Scanner	
 * 
 *	- Output to CONSOLE are written using the below output steam classes:
 * 	  			-> ByteArrayOutputStream
 * 				-> CharArrayWriter
 * 				-> BufferedOutputStream, BufferedWriter
 * 				-> OutputStream(Most commonly used) : System.out.print() & System.out.println() 
 *  		    -> Scanner		 
 */
package Section2;

